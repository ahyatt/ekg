#+title:                 ekg, the Emacs Knowledge Graph
:PREAMBLE:
author:                Andrew Hyatt
#+email:                 ahyatt@gmail.com
#+language:              en
#+options:               't toc:nil author:t email:t num:t
#+startup:               content
#+texinfo_filename:      ekg.info
#+texinfo_dir_category:  Emacs
#+texinfo_dir_title:     EKG: (ekg)
#+texinfo_dir_desc:      A note taking application for emacs using sqlite
#+texinfo_header:        @set MAINTAINER Andrew Hyatt
#+texinfo_header:        @set MAINTAINEREMAIL @email{ahyatt@gmail.com}
#+texinfo_header:        @set MAINTAINERCONTACT @uref{mailto:ahyatt@gmail.com,contact the maintainer}

#+texinfo: @insertcopying
:END:

This is the ekg manual, which describes the operation and customization of the ekg package. All information here is relevant to the released version only.

The README is also informative, has screenshots, and can be found in the source and in the git repository, which is at https://github.com/ahyatt/ekg.

#+toc: headlines 4

* Introduction
The ekg module is a simple but opinionated note taking application, for emacs.
It is a substitute for such other emacs applications such as org-roam or denote.
ekg stands for /emacs knowledge graph/.

Data is completely stored in a sqlite database. Notes are organized around tags,
and you can view many notes by looking at one or more tags. This provides a
read-only view of various notes, which you can navigate between and choose to
edit in a separate buffer.

The editing of notes combines the editing of the text of the note with various properties stored in the database such as the tags of the note.
* Installation
** Installing via Melpa
This is the easiest and recommended way to install ekg. If you have not set up Melpa yet, follow the instructions at https://melpa.org/#/getting-started.

There is no need to use Melpa Stable, because development happens in a branch and is not integrated until it is deemed stable. When bugs are discovered, fixes are pushed to the main branch soon, so it is usually a good idea to keep your version up to date.

There are many ways to use Melpa to download ekg, but using =use-package= is the easiest way, and recommended because it allows you to get the pacakge and configure it in one place.  An example use is below.

#+begin_src emacs-lisp
(use-package ekg
  :bind (([f11] . ekg-capture)))
#+end_src
** Installing by hand
If you wish to install by hand, you need to make sure to install the triples library, found in GNU ELPA, and at https://github.com/ahyatt/triples.

Clone the ekg library, from whatever branch you would like to use (=main= corresponds to the release version, and =develop= is where development of the next version happens). Add your source directory and require ekg. The following is an example assuming you cloned ekg into =~/src/ekg=, and the triples library is already installed.

#+begin_src emacs-lisp
(add-to-list 'load-path "~/src/ekg")
(require 'ekg)
#+end_src
* Changelog
** Version 0.2
- Added hooks ~ekg-add-schema-hook~, ~ekg-note-pre-save-hook~, ~ekg-note-save-hook~, ~ekg-note-delete-hook~, and ~ekg-note-add-tag-hook~  to enable customization.
- New commands =ekg-show-notes-latest-captured=, =ekg-show-notes-latest-modified=, for showing notes created or modified recently.
- Introduced variable ~ekg-notes-size~ to control the default page size for limited views such as =ekg-show-notes-latest-captured=.
- Added templating.
- Added embedding as an optional add-on, to enable note similarity and note search; requires an account at OpenAI or similar embedding provider.
- Added new function ~ekg-active-notes~ to easily get all non-trashed notes.
- Improved ability to have note list buffers that have flexible titles and operation, notably improving the =ekg-show-notes-in-trash= command.
- Standardized buffer names for =ekg-notes-mode= buffers, which all are prepended with "ekg" and surrounded by asterisks, to denote that they are non-file-based.
- Added the documentation you are reading right now.
- Fixed bug interfering with completion at the beginning of the tag property line.
- Fix for ~ekg-notes-refresh~ incorrectly calling ~ekg--show-notes~.
* Database
By default, ekg uses the default triple database, which is set in the variable ~triples-default-database-filename~. The default value of this is =~/.emacs.d/triples.db=.  You can specify a different name if you want the ekg database to be not shared with any other user of the triple package, by customizing the variable ~ekg-db-file~. When this is ~nil~, it uses the filename up to the triples package.
* Concepts and data model in ekg
The ekg package is built on a flexible database scheme called "triples", where everything is stored as a graph structure; a subject, a predicate, and an object. The implication for the ekg package is that new kinds of data is easy to add, and lives alongside other data. Values of properties, stored as "objects" can themselves have values by adding data where the same value is the "subject". If you plan to do extensive integration work in elisp, it will help to understand these concepts, and the best way to do so is reading the triples package README.

For notes, we can think of the subject of the triples as an ID. Notes are created, and have the following potential properties by default:
  - ID
  - Tags
  - Text and it's major mode
  - Creation time and modification time
  - Title

The ID for notes is by default an integer UUID. However, you can have notes about anything. In EKG an ID can be a resource identifier as well, such as a URL.  When this happens, the ID is the data interesting in its own right.

Tags may have spaces, but cannot have commas, which are used to separate them when showing them to the user and parsing them back out into properties to store.

Because of the triples model, there is data about the tags for each note. Tags themselves just have type markers indicating they are tags, and can dynamically query for all notes with their tag, so tags always have a current list of notes with their tag.

* Understanding and editing the note buffer
When capturing or creating a note, the note buffer has two areas important to understand. The first is the area for note properties, which has a different background color.  The second is the area for the note text.
** Note properties
The properties shown in the note property area come from the data stored in the database for the entity. At a minimum, there will be tags.

#+texinfo: @noindent
A property is displayed with a label, and the value, such as
#+begin_quote
Tags: emacs, ekg
#+end_quote

#+texinfo: @noindent
Changing these values, when saving the note, will change the values that will be stored in the database.

#+texinfo: @noindent
New properties can be added manually, so if you wanted a title, you can add it to the property list.
#+begin_quote
Title: This is my title
#+end_quote

#+texinfo: @noindent
It's important to note that everything in the section with the different background color is a property and will be treated as such. Text that doesn't look like a property there will cause problems, and properties outside this area will instead be treated as note text.

#+texinfo: @noindent
Not every property has a representation in the property list, only the properties which users may want to change manually.

#+texinfo: @noindent
Tag properties have completion to tags built-in, so adding tags you should be able to choose from available tags when typing a new tag into the properties section, or add a new tag that has not yet been used.

#+texinfo: @noindent
Ekg makes some effort to make sure that the user doesn't accidentally extend the property section without adding actual properties, since this will likely result in a confusing experience for the user.
** Note text
Below is the property section is the note section. The text could be anything (or nothing). This is the body text of the note, where you write down whatever
you want to note about, that is relevant to the tags for the note.

There are three modes for the note text: =text-mode=, =markdown-mode=, and =org-mode=. More can be added by customizing the variable ~ekg-capture-acceptable-modes~, just
make sure its a mode that makes sense for notes. The default mode is configured in ~ekg-capture-default-mode~, but can be changed when capturing with the command =ekg-capture-change-mode=.
** A warning about org-mode
Org-mode notes are primarily to use org-mode formatting on. Org-mode has a lot of funtionality, but much of it depends on the assumption that the buffer is all for use by org-mode (not true in this case, because of the properties portion), and the assumption that the buffer is visiting a file, which is also not true. In particular, attachments will not work, and ekg-notes cannot be added to the agenda.
* Capturing notes
=ekg-capture= is the command to capture a note. In ekg this is probably the most frequently used command. It will create a new buffer called =*EKG Capture*=. By
default, it will have the current date tag, such as "date/2023-02-21".

#+texinfo: @noindent
 =ekg-capture-url= will capture a note associated with a URL resource, and with a  given title as the title of the page. The idea is that the note is annotating
 the reference itself as a "literature note". The title also appears as a tag,  so other notes can reference this if needed. For example, if the URL is  http://example.com, and the title is "An example URL", the properties buffer  will have the following:

 #+begin_quote
Resource: http://example.com
Tags: doc/an example url, date/2023-02-25
Title: An example URL
 #+end_quote

 Capturing URLs is a bit clunky as is, if you can wrap it in a function to  supply the name and url of the active browser tab, then you can create a much  easier experience. The following is an example for users of Google Chrome on  Mac OS X.

 #+begin_src emacs-lisp
(defun my/ekg-capture-url ()
  (interactive)

  (ekg-capture-url
   (do-applescript "tell application \"Google Chrome\" to return URL of active tab of front window")
   (do-applescript "tell application \"Google Chrome\" to return Title of active tab of front window")))
#+end_src

#+texinfo: @noindent
A final way to capture notes comes from a buffer that is viewing a list of notes, in =ekg-notes-mode=. You can call =ekg-notes-create=, which will capture a new note with whatever tags (if any) are associated with the notes buffer.

#+texinfo: @noindent
To save any note that is being captured, press =C-c C-c= or call =ekg-capture-finalize=. To cancel, just kill the buffer.
** Templates
Ekg comes with a built-in way to have templates. When a note adds a tag, ekg searches for notes with both the tag added, and the tag "template". Any note with those two tags will be added by default to the text of the buffer.

For example, if there is a note with tags, "daily reflection" and "template", with the text "What did you learn today?", adding the tag "daily reflection" to a note will cause the text "What did you learn today?" to appear.

The adding of templates happens whether intially when setting up the capture buffer, or later when the users completes a tag. Tags added without completion won't trigger this behavior, since at the moment ekg will not be able to understand that a tag has changed.

The other tag searched for can be changed by customizing ~ekg-template-tag~, which by default is just "template".

This functionality is enabled through the function =ekg-on-add-tag-insert-template= in the variable ~ekg-note-add-tag-hook~, and can be turned off from removing it from that hook.

#+begin_src emacs-lisp
(remove-hook 'ekg-note-add-tag-hook #'ekg-on-add-tag-insert-template)
#+end_src
** Changing the initial tags of a note
The variable ~ekg-capture-auto-tag-funcs~ has a list of functions to call to add tags. Each function is called, and returns a list (or ~nil~, the empty list), which are all added to a new note. By default, this variable has the function =ekg-date-tag=, which returns the tag of today's date. If you do not want this, you can remove this function. You can also add your own functions to add the year, the week number, or any tag you feel is appropriate.
* Viewing tags or notes
There are several functions to view notes in various ways. All of these show a list of notes in read-only view, that can be navigated and interacted with. This is a =ekg-notes-mode= buffer.

=ekg-show-notes-with-tag= will show all notes tagged with the given tag.

=ekg-show-notes-with-any-tags= will show all notes that have any of the tags given.

=ekg-show-notes-with-all-tags= will show all notes that have all of the tags given.

=ekg-show-notes-for-today= will show the notes taken today.

=ekg-show-notes-latest-captured= will show a number of notes from newest to oldest. The number is 20 by default, but can be changed by customizing ~ekg-notes-size~.

=ekg-show-notes-latest-modified= will show a number of notes from newest to oldest, but by modification time, not by creation time. The number is also 20 by default and can be changed by customizing ~ekg-notes-size~.

=ekg-show-notes-in-trash= will show the notes in the trash (see the [[#trash][trash]] section for details on how this works).
** Commands in the notes buffer
The notes buffer is navigated via the following commands (the default binding is also given):

=ekg-notes-tag= (=t=), open another notes buffer showing notes with any of the tags of current note.

=ekg-notes-open= (=o=), edit the currently selected note.

=ekg-notes-delete= (=d=), trash the current note (or, if this is the trash list, truly delete it).

=ekg-notes-remove= (=r=), remove the note buffer's tags from the currently selected note. This does not delete the tags but prepends them with a trash prefix so they are ignored, but can be restored if the user wishes. For more details, see the [[#trash][trash]] section.

=ekg-notes-browse= (=b=), open the resource attached to the current note, if it exists, otherwise do nothing.

=ekg-notes-select-and-browse-url= (=B=), select from all the titles of URL resources in the any of the notes, and browse the URL.

=ekg-notes-refresh= (=g=), refresh the list of notes in the current buffer, to make sure any new notes or removed notes are updated in the list.

=ekg-notes-create= (=c=), capture a new note with all the tags associated with the list.

=ekg-notes-next= (=n=), move selection to the next note.

=ekg-notes-previous= (=p=), move selection to the previous node.

=ekg-notes-any-note-tags= (=a=), open a new notes list showing any of the tags that appear in the selected note.

=ekg-notes-any-tags= (=A=), open a new notes list showing any of the tags that appear in any of the notes in note list. In other words, if the buffer was displaying notes with tag =emacs=, and there are two notes displayed, one with tags =emacs= and =org-mode=, and the other with =emacs= and =ekg=, a new buffer displaying notes with any of the tags =emacs=, =org-mode=, or =ekg= is created.

Many of these commands use the notion that notes lists have associated lists of tags. That is the case for many commands, but not all. For example,
=ekg-show-notes-latest-captured=, =ekg-show-notes-latest-modified=, and =ekg-show-notes-in-trash= have no associated tags.
** Customizing note display in =ekg-notes-mode=
The variable ~ekg-format-funcs~ has functions to run to format what ekg displays to the user. They are each run on a temporary buffer with the note text in it, and can make whatever changes necessary before they are displayed in a note list.
* The trash
:PROPERTIES:
:CUSTOM_ID: trash
:END:

Notes deleted from note lists (=ekg-notes-mode=) buffers are not deleted outright, but rather put in the trash. There are two concepts here: trashed tags, and trashed note. A trash tag is a tag with the prefix "trash/" added. Such tags are ignored and not shown to users except when editing notes, at which point the user can choose to remove the trash prefix to un-trash them. This is what happens when =ekg-notes-remove= is called; it trashes all the tags associated with the current list.

If all of a notes tags are trashed, then the note itself is considered to be trashed. Trashed notes can be seen by calling =ekg-show-notes-in-trash=. If notes are deleted from this list, they are deleted permanently. However, if you want to un-trash the note, you can edit the note and remove the trash prefix from one or more of the tags.
* Links to ekg in org-mode
Both notes in ekg and certain note list buffers can be stored and linked to in org-mode. To store a link to a note, you have to edit that note and call =org-store-link=. That function can also be called in a =ekg-notes-mode= buffer created by =ekg-show-notes-with-any-tags=. Other list types currently will just store their tags assuming the user wants a link to a list with any of the tags in the list.
* Importing from org-roam and logseq

* Importing from org-roam
You can import your notes from org-roam. This will turn all titles into tags, and all links will become tags as well. At the moment, this is done via executing elisp, since importing can be fairly idiosyncratic, and ekg and org-roam have different ways of expressing the same thing that you may want to change. It's best if you looked over =ekg-org-roam.el= and see what is going on, but at least read the following description before manually executing ~(ekg-org-roam-import)~.

The import is idempotent, so it always will import to the same entities, overwriting older data with new data. If you want to update what is in ekg, you can just rerun the import. In the import, titles and tags will have any commas removed, since commas are commonly used in multiple completion as a separator, so anything with commas would otherwise cause problems when selected. If you have tags you want to turn into prefixes (which is a good idea for tags widely applied, which essentially act as a categorization), you can add those tags to the list at ~ekg-org-roam-import-tag-to-prefix~. For example,

#+begin_src emacs-lisp
(setq ekg-org-roam-import-tag-to-prefix (append ekg-org-roam-import-tag-to-prefix '("idea" "person")))
#+end_src

Then, when a note is found that is tagged with "idea", but with title "emacs is a powerful tool", then the title in org-roam will be turned into the ekg tag "idea/emacs is a powerful tool", and anything linked with it will also get the same prefix.

Logseq is also imported as well when =ekg-org-roam-import= is executed, if any files are found.  There isn't true compatability, since ekg does not support many logseq functions.
* Backups
By default, the ekg package will back up its database, using the backup functionality built into the triples library. By default, behavior is set by ~ekg-default-num-backups~, set to =5= by default, and ~ekg-default-backups-strategy~, set to =daily=. These are, on first use of ekg, stored in the database itself, but it can be set again at any time by running:
#+begin_
src emacs-lisp
(triples-backups-setup ekg-db ekg-default-num-backups
                       ekg-default-backups-strategy)
#+end_src

The strategy can be one of the defaults of =daily=, =weekly=, =every-change=, or =never=, and new methods can be defined as well. See the implementation in =triples-backups.el= for more information.
* Database maintenance
You may occasionally notice that certain tags are obsolete and have no notes, or notes exist that are empty, or various other annoyances. You can call =ekg-clean-db=, which will:

- First, force a backup.
- Remove all tags with no uses.
- Remove notes with no text, or just a "*", which is something that often happens with org-mode buffers.
* Customizing ekg with hooks
You can customize the behavior of ekg in a number of ways.

First, you can create your own schema to store your own data.  The hook ~ekg-add-schema-hook~ is called whenver the database is connected to.  At that point, ekg adds all of its schema, and runs the hooks in this variable.  Adding schema is idempotent, so it can be called any number of times without causing problems.  Adding schema can be done by calling the triples library.  For details on how to create schema, you can either look at the ekg implementation for example, or the triples library README for an overview of how it works.

The ~ekg-note-pre-save-hook~ is called before saving a note, and ~ekg-note-save-hook~ is called after saving, but in the same database transaction as the save.

The ~ekg-note-delete-hook~ is called when deleting a note.

The ~ekg-note-add-tag-hook~ is called when adding a tag, either via the initial tags added to a new note, or tags added after completing a new tag in the note's property list.
* Integration with ekg
The ekg package is designed to be easy to integrate with.  For example, if you want create a note automatically in one of your functions, you can write:

  #+begin_src emacs-lisp
  (defun my/log-to-ekg (text)
    "Log TEXT as a note to EKG's date"
    (ekg-save-note (ekg-note-create text 'text-mode `(,(ekg-tag-for-date) "log"))))
#+end_src

#+texinfo: @noindent
If you wanted to re-use an existing note and append to it, you can do that as well.

#+begin_src emacs-lisp
(defun my/log-to-ekg (text)
  "Log TEXT as a note to EKG's date, appending if possible."
  (let ((notes (ekg-get-notes-with-tags (list (ekg-tag-for-date) "log"))))
    (if notes
        (progn
          (setf (ekg-note-text (car notes)) (concat (ekg-note-text (car notes)) "\n" text))
          (ekg-save-note (car notes)))
      (ekg-save-note (ekg-note-create text 'text-mode `(,(ekg-tag-for-date) "log"))))))
#+end_src

There isn't a special API, but the basic defuns such as ~ekg-save-note~, ~ekg-note-create-text~, ~ekg-get-notes-with-tags~, ~ekg-get-note-with-id~, along with the struct ~ekg-note~ are good starting points.

If you add schema and you want the user to be able to modify it, you should supply new alist entries to ~ekg-metadata-parsers~, and ~ekg-metadata-labels~.
* Extras
The ekg module can have any number of functionality additions. These may appear as other packages with other maintainers, but some are included as part of this package.
** Embeddings
The embeddings functionality can be turned on by requiring the embeddings file, such as:

#+begin_src emacs-lisp
(require 'ekg-embedding)
#+end_src

This module contains functionality to explore similar notes and search using techniques associated with large language models. The idea behind an embedding is that it is an abstract representation of text, represented as a multi-dimensional vector. Because it is just a vector, you can compare the distance between different embeddings, and embedding vectors that are similar should represent similar concepts. This can be used to find similar notes, but also to search, where the search string is transformed into an embedding.

Using embeddings in ekg are dependent on an API to transform text into embeddings. This is not something that can be done locally. Right now such APIs are rare, but Open AI does offer this, so this is what we support out of the box.

To get started, [[https://openai.com/join/][sign up for Open AI]] and get an API key, which you should store in ~ekg-embedding-api-key~. I highly recommend you set limits to how much you can be charged per month. Fortunately, calculating embeddings is cheap, and should cost much less than 1 USD for all but the largest databases.  The embeddings module will send the contents of the your notes, your searches, or sometimes buffer (for =ekg-embedding-show-similar-to-current-buffer=) so please be aware of the privacy implications, and make sure you are comfortable with the embedding provider receiving your data.

Important: *your API key is a secret key, so do not store it anywhere it can be seen, such as a public git repository*.

Once you have this set up, and you have already called ~(require 'ekg-embedding)~ you can call =M-x ekg-embedding-generate-all=. This may take a long time as each
embedding has to be generated separately with its own API call. Once you've done this, you can call, in =ekg-notes-mode=, =ekg-embedding-show-similar= to get a list of similar notes. You can also call =ekg-embedding-search= to perform a search over your notes using embeddings.  In any buffer, you can call =ekg-embedding-show-similar-to-current-buffer= to similar notes to whatever the text is in the curent buffer.
** Logseq
ekg can export to logseq, a PKMS application that can run on a laptop or phone.  It is particularly convenient as a way to view notes on your phone, and various synchronization solutions exist to sync local files with your phone.  ekg and logseq are not designed to be perfectly compatible, because each one has a different design on how it organizes notes.  Because of this, perfect compatibility is not possible.  The ekg and logseq compatibility are designed to favor ekg's system when a conflict arises.

There are two ways to use logseq, one is maintaining logseq as an export-only copy of ekg data, where you don't plan to modify anything in logseq, just using it to access your notes on other platforms.  Exporting from ekg is destructive, though, so without an initial import, *exporting will overwrite logseq files with data from ekg, so it may destroy data*.  The other way is to sync bidirectionally.  This starts by importing anything from logseq that has never been imported before, and then writing ekg's data on top.  This will preserve data, but will lose the initial formatting of ordering of pages.  Both of these methods, then, will significantly impact your logseq notes.  *It is highly advised to back up your logseq files before starting*.

To export to logseq, start by requiring the =ekg-logseq= module and setting up ~ekg-logseq-dir~, which points to the base of your logseq file (where there is a "pages" and "journals" directory):
#+begin_src emacs-lisp
(require 'ekg-logseq)
(setq ekg-logseq-dir "~/my/logseq")
#+end_src

If you wish to maintain logseq as a read-only copy of ekg, just run =ekg-logseq-export= when you wish to export data.  This currently may take a few seconds to a minute, depending on how much data you have.  We attempt to not write any files that are unchanged.  To have a bidirectional synchronization, run =ekg-logseq-sync=, which will first import data from logseq, then export data.

*** Exporting 
When exporting, it's important to understand the differences between ekg and logseq.  Logseq has one page per tag, and one page is one file.  Within the page there are many sections, which can be individually referenced.  The pages are the same as tags, and the sections are similar to ekg notes.  However, logseq has a design where the user is seeing mostly one page at a time.  ekg's design is one where notes are shown in a variety of contexts, mostly tag related, but not always.  In logseq, notes lives in a page and is referenced from others, whereas in ekg, notes don't "live" anywhere, but are just tagged.  To compensate for this difference, we export notes based on their first non-date tag as the page where the text will apear, and reference other tags, where they will appear as backlinks.  In addition, in org-mode, notes in a page appear as top-level outlines, which are supposed to have text for the outline node.  If there is an ekg note with a title, the title will appear as the text, otherwise the outline node will just read "Untitled note".  Because this initial headline is where various properties are stored, and is followed immediately by tags, it makes sense that this is a title instead of just part of the content.

#+texinfo: @noindent
For example, take the following note:
#+begin_example
Tags: date/2023-04-05, ekg, logseq

ekg can export into logseq!
#+end_example

This will be exported into "pages/ekg.org":

#+begin_example
,#+title: ekg

,* Untitled note
:PROPERTIES:
:ID: 33134561605
:EKG_LAST_MODIFIED: 1681071520
:END:
#[[2023-04-05]] #[[logseq]]
ekg can export into logseq
#+end_example

#+texinfo: @noindent
Each node points to its ID which is from ekg (but, if it was originally imported, the ekg ID might originally be from logseq).  This is to keep track of what was exported, so we do not re-import it.  For now, even if the data is changed, it is not re-imported.  Files for "pages/logseq.org" and "journals/2023-04-05" will also be created, although they won't have any content from this note.
*** Importing
#+texinfo: @noindent
Imports from logseq will return all top-level items as separate notes.  So, for example, assuming we're reading from the logseq file "pages/logseq.org":

#+begin_example
,* This is my first time trying logseq  #testing
,* The org compatibility here is especially nice  #org

   It really helps me feel comfortable in using the various formatting options I had gotten used to.
#+end_example

#+texinfo: @noindent
This will turn into two notes, one that has text "* This is my first time trying logseq  #testing", and with tags =logseq=, and =testing=, and the other with the rest of the text, with the tags =logseq= and =org=.

#+texinfo: @noindent
There are a few things to be aware of.  In logseq, any level of the hierarchy can have an id and be referenced separately.  In ekg, we don't support notes inside of other notes, so these will be imported in the context of the parent note, and won't be available to reference as its own separate note.  Also, logseq has other functionality not supported by ekg, such as queries and potentially anything provided by plugins.  These will be imported as-is to ekg, but without any corresponding functionality.


